#summary Detailed tutorial for the LemonTree software.

= Copyright and License =

Copyright (c) 2012 Eric Bonnet, Tom Michoel. 

LemonTree is free software, released under the terms of the GNU general
Public License (GPL) v2 ([http://www.gnu.org/licenses/old-licenses/gpl-2.0.html link]).

LemonTree is free of charge for the academic world and non-profit organizations.  For any commercial usage of this software, please contact us.

The software is using the following Java libraries, provided with the package:

  * Colt library for high performance computing ([http://acs.lbl.gov/~hoschek/colt/license.html web]).
  * XOM library for xml parsing ([http://xom.nu web]).
  * Epsgraphics library to create figures ([http://sourceforge.net/projects/epsgraphics/ web]).
  * Apache CLI library to parse command line arguments ([http://commons.apache.org/cli/ web]).
  * The BiNGO Java library to calculate GO enrichment ([http://www.psb.ugent.be/cbd/papers/BiNGO/ web]).

Coding crew:
  * Tom Michoel
  * Eric Bonnet
  * Anagha Joshi
  * Steven Maere

Requirements:
  * Java version 1.6 or higher installed.

= Installation =

The LemonTree software is a command line program, there is no graphical user interface (at this stage). The package is a zipped archive that you have to unzip in the directory of your choice.

Let's take an example. Say the archive was unpacked in /home/jdoe/progs/. You can call the program by the command:

{{{
java -jar /home/jdoe/progs/lemone.jar
}}}

You can pass memory size parameters to the java virtual machine, it might help if you have a large dataset. For example, this command is allocating 10 Gigabytes of memory (max.) for the program:

{{{
java -Xmx10g -jar /home/jdoe/progs/lemone.jar 
}}}

An alternative to launch the program is to set the CLASSPATH environmental variable to include the path to the LemonTree jar file and also to all the Java libraries (located in the "lib/" directory of the package). Then you can launch the program with the command:

{{{
java lemontree.modulenetwork.RunCli
}}}

= Synopsis =

The purpose of the LemonTree software package is to create a module network from expression data. The end result is a set of gene clusters (co-expressed genes), and their associated "regulators".  To achieve this goal, you'll have to follow the LemonTree recipe, which consists of different steps that have to be performed. For each step, you'll have to use one or more specific part of the software, which are
designated as "tasks". There are three fundamental tasks:

  * Generate several cluster solutions ("ganesh" task).
  * Merge the different cluster solutions using the fuzzy clustering.
  * Assign regulators to each cluster, producing the module network ("regulators" task).

= Tutorial =

In this guided example, we will infer a module network from cancer related data. The data was taken from the TCGA project ([http://cancergenome.nih.gov/ The Cancer Genome Atlas]). More specifically, we will use expression data for mRNA and microRNA from Glioblastoma samples. 

Please note that we have created very small datasets to keep the computational time short. Thus, the results do not aim to be representative. Note also that if you repeat the procedure, you might get slightly different results due to the small size of the examples and to stochastic fluctuations.


== Ganesh task ==


Functions: cluster genes from a matrix (rows) using a Gibbs sampling procedure.

The first step (clustering) is done on the mRNA expression data only.
We did a selection of genes having non-flat profiles, keeping genes having a standard deviation above a certain value (determined by looking at the histogram). We usually use 0.5 as the cutoff
score, but this might depend on the dataset. In this example, we have an input matrix of 500 genes and 50 samples. The data is centered and scaled (by row) to have a mean of 0 and a standard deviation of 1. we can generate a cluster solution with the command:

{{{
java -jar lemontree_v3.0.jar -task ganesh -data_file data/expr_matrix.txt -output_file cluster1
}}}

This step will be repeated multiple times, using the same command, only
changing the name of the output file. Here we have generated 5 runs, prefixed  cluster1, 2, 3, 4, 5. The files are in the "results" directory.

== Tight clusters task ==
Here, we are going to generate a single, robust clustering solution from all the individual solutions generated at the previous step.

{{{
java -jar lemontree_v3.0.jar -task tight_clusters -data_file data/expr_matrix.txt -cluster_file cluster_file_list -output_file tight_clusters.txt
}}}

The "cluster_file" is a simple text file, listing the location of all the individual cluster files generated at the "ganesh" step.

By default, this option is keeping only clusters that have a minimum of 10 genes. This number can be easily changed by overriding the parameter "min_clust_size" with another value on the command line for this task.

== Regulators task == 

In this task, we are going to assign sets of "regulators" to each of the modules using a probabilistic scoring, taking into account the profile of the candidate regulator. 

The candidate regulators are divided in two different types, depending on the nature of their profiles: continuous or discrete. The first type can be for example transcription factors selected from the expression matrix, or microRNA for which we have expression profiles. The latter can be for example clinical parameters (such as the grade of a disease, represented by some discrete values). In all cases, we must have profiles that match the samples of the tight clusters defined previously (missing values are allowed).

For this tutorial, we have selected a set of 85 candidate regulators from the mRNA expression matrix, based on their GO annotation (corresponding to either transcription factors, signal transducers or kinase activity). We have also selected a set of 100 microRNAs, for which we have expression profiles measured by dedicated microarrays. Both datasets correspond to continuous types of data. We will assign regulators separately for the two types.

{{{
java -jar lemontree_v3.0.jar -task regulators -data_file data/expr_matrix.txt -reg_file data/reg_list.txt -cluster_file tight_clusters.txt -output_file reg_tf
}}}

The "reg_file" option is a simple text list of candidate regulators that are present in the expression matrix. If the regulators are discrete, it is mandatory to add a second column in the text file, describing the type of the regulator ("c" for continuous or "d" for discrete).

Note that this command will create four different output files, using the "output_file" parameter as the prefix for all the files.

  * reg_tf.topreg.txt: Top 1% regulators assigned to the modules.
  * reg_tf.allreg.txt:  All the regulators assigned.
  * reg_tf.randomreg.txt: Regulators assigned randomly to the modules.
  * reg_tf.xml.gz: xml file containing all the regulatory trees used for assigning the regulators.